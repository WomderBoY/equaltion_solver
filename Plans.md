### **项目构建计划：方程迭代求解可视化工具**

#### **总览**

*   **目标**: 按照项目说明书，分阶段、有条理地完成一个功能完备、交互良好、代码清晰的可视化工具。
*   **方法论**: 采用迭代式开发。我们首先构建一个最小可行产品（MVP），然后逐步扩展功能，最后进行优化和加固。
*   **预估总时间**: 约 15-20 个工作日（假设为一名有基础前端经验的开发者）。

---

### **第一阶段：地基搭建与环境设置 (预计：2-3天)**

**目标**: 创建项目骨架，搭建静态页面，并集成所有必要的第三方库。此阶段结束时，我们应该有一个可视化的、但尚无交互逻辑的页面框架。

*   **任务 1.1：项目结构初始化**
    *   [ ] 创建项目根目录。
    *   [ ] 按照设计，创建 `index.html`, `style.css` 和 `main.js` 文件。
    *   [ ] 创建 `js/` 目录，并在其中创建 `ui.js`, `solver.js`, `plotter.js`, `state.js` 四个空的 JS 文件。

*   **任务 1.2：HTML 骨架与 CSS 布局**
    *   [ ] 在 `index.html` 中编写所有静态 HTML 结构，包括头部、主容器、三个面板（控制、可视化、结果）的 `div` 结构，以及表格的 `<thead>`。
    *   [ ] 在 `style.css` 中使用 Flexbox 或 Grid 完成页面的基本三栏布局，并设置朴素的样式（边框、间距、字体等），确保在不同屏幕尺寸下布局基本稳定。

*   **任务 1.3：集成第三方库**
    *   [ ] 在 `index.html` 的 `<body>` 底部，通过 CDN 链接引入 `Math.js` 和 `function-plot.js`。
    *   [ ] 验证库是否加载成功：可以在 `main.js` 中简单调用 `console.log(math.sqrt(-4).toString())` 和 `functionPlot({ target: '#plot', data: [{ fn: 'x^2' }] })` 来测试。

*   **任务 1.4：模块化 JS 文件链接**
    *   [ ] 在 `index.html` 中，在引入库之后，依次引入你的四个 JS 模块文件，确保 `main.js` 在最后。
    *   [ ] 在 `state.js` 中定义并导出 `appState` 对象。在 `main.js` 中确认可以访问到它。

**阶段性成果**: 一个静态的、样式简洁的网页，其中包含一个由 `function-plot` 生成的简单函数图像。

---

### **第二阶段：核心功能 MVP - 实现牛顿法 (预计：4-5天)**

**目标**: 端到端地实现一个完整的方法——牛顿法。这能验证整个架构（状态->计算->UI/绘图更新）是可行的。

*   **任务 2.1：动态 UI 生成**
    *   [ ] 在 `ui.js` 中，实现 `updateInputForm(method)` 函数。此函数能根据传入的方法名，动态地向 `<div id="input-area">` 中添加或删除 HTML 输入框。
    *   [ ] 在 `main.js` 中，监听方法选择下拉框的 `change` 事件，并调用 `UI.updateInputForm()`。

*   **任务 2.2：状态与计算逻辑**
    *   [ ] 在 `state.js` 中，完善 `appState` 对象，包含 `currentMethod`, `funcString`, `initialValue`, `history` 等。
    *   [ ] 在 `solver.js` 中，实现 `newton(f, f_prime, x_k)` 函数。此函数是纯数学计算。

*   **任务 2.3：核心交互流程**
    *   [ ] 在 `main.js` 中，为“单步迭代”按钮添加事件监听器。
    *   [ ] 在监听器回调中，实现核心逻辑：
        1.  从 UI 获取函数字符串和初值。
        2.  **首次点击**: 使用 `math.js` 解析函数 (`math.parse().compile()`) 和求导 (`math.derivative().compile()`)，并存入 `appState`。初始化 `appState.history`。
        3.  调用 `solver.newton()` 进行计算。
        4.  将新结果更新到 `appState.history` 中。

*   **任务 2.4：结果与可视化更新**
    *   [ ] 在 `ui.js` 中，实现 `updateResultsTable(history)`，它会根据 `appState.history` 渲染结果表格。
    *   [ ] 在 `plotter.js` 中，实现 `drawFunction(fnString)` 和 `drawNewtonTangent(f, f_prime, x_k)`。后者需要计算切线方程，并使用 `function-plot` 的 `annotations` 或 `data` 数组来绘制切线和标记点。
    *   [ ] 在 `main.js` 的迭代按钮回调中，调用上述 UI 和 plotter 函数来更新视图。

**阶段性成果 (MVP)**: 用户可以选择牛顿法，输入方程和初值，每点击一次迭代按钮，就能在表格和图表中看到一步迭代的结果和对应的切线。

---

### **第三阶段：功能扩展 - 实现所有剩余方法 (预计：5-6天)**

**目标**: 在 MVP 的成功基础上，横向扩展，实现所有其他迭代方法。

*   **任务 3.1：实现简单迭代法与埃特肯法**
    *   [ ] 在 `solver.js` 中添加 `simpleIteration` 和 `aitken` 的计算逻辑。
    *   [ ] 在 `plotter.js` 中添加 `drawCobweb(phi, x_k, x_k+1)` 函数，用于绘制蛛网图。这需要绘制 `y=x`，以及从 $(x_k, x_k)$ 到 $(x_k, \varphi(x_k))$ 再到 $(x_{k+1}, x_{k+1})$ 的线段。
    *   [ ] 在 `main.js` 的迭代逻辑中添加 `if/else` 或 `switch` 分支来处理这两种方法。

*   **任务 3.2：实现弦截法（单点与双点）**
    *   [ ] 在 `solver.js` 中添加 `secantSingle` 和 `secantDouble` 的计算逻辑。
    *   [ ] 在 `plotter.js` 中添加 `drawSecantLine(f, x_k-1, x_k)` 函数，用于绘制割线。
    *   [ ] 在 `main.js` 的迭代逻辑中添加对这两种方法的处理。

*   **任务 3.3：实现重置功能**
    *   [ ] 在 `main.js` 中为“重置”按钮添加事件监听器。
    *   [ ] 实现一个 `reset()` 函数，该函数负责：
        1.  清空 `appState` 中的历史记录和计算结果。
        2.  调用 `ui.js` 中的函数清空结果表格和消息。
        3.  调用 `plotter.js` 中的函数清除所有辅助线和标记点，只保留主函数图像。

**阶段性成果**: 应用支持所有五种迭代方法，并能正确地进行计算和可视化。重置功能工作正常。

---

### **第四阶段：健壮性与用户体验优化 (预计：4-6天)**

**目标**: 提升应用的稳定性和易用性，处理各种边界情况和用户错误。

*   **任务 4.1：收敛与发散判断**
    *   [ ] 在 `main.js` 的迭代逻辑中，每次计算后检查：
        *   收敛条件：$|x_k - x_{k-1}| < \epsilon$。
        *   发散条件：$|x_k|$ 超过一个巨大阈值，或迭代次数超限。
    *   [ ] 如果满足条件，更新 `appState` 的 `isConverged` 或 `isDiverged` 标志，并禁用“单步迭代”按钮。
    *   [ ] 在 `ui.js` 中实现 `showMessage(message, type)` 函数，用于在消息区域显示“已收敛”、“警告：可能发散”等提示。

*   **任务 4.2：错误处理**
    *   [ ] 使用 `try...catch` 块包裹 `math.js` 的解析和计算部分。
    *   [ ] 如果捕获到错误（如语法错误、定义域错误 `log(-1)`），则在 UI 中向用户显示清晰的错误信息。
    *   [ ] 检查计算结果是否为 `NaN` 或 `Infinity`，并作为发散处理。

*   **任务 4.3：UI/UX 优化**
    *   [ ] **自适应视图**: 研究 `function-plot` 的 `xAxis.domain` 和 `yAxis.domain`，尝试在每次迭代后动态调整坐标范围，确保新点和辅助线可见。
    *   [ ] **交互反馈**: 为按钮添加 `:hover` 和 `:active` 状态。
    *   [ ] **代码审查与重构**: 回顾所有代码，添加必要的注释，确保模块职责清晰，移除冗余代码。

*   **任务 4.4：最终测试**
    *   [ ] 寻找一些典型的数值分析教科书案例（收敛的、发散的、震荡的）。
    *   [ ] 将这些案例输入到你的工具中，验证计算结果和可视化过程是否与理论一致。

**最终成果**: 一个功能完整、运行稳定、体验友好的方程迭代求解可视化工具。